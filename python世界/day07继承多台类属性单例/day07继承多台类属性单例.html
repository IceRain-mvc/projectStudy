<!DOCTYPE html>
  <html>
    <head>
      <title>继承</title>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      
      <link rel="stylesheet" href="file:///C:\Users\Administrator\.vscode\extensions\shd101wyy.markdown-preview-enhanced-0.3.5\node_modules\@shd101wyy\mume\dependencies\katex\katex.min.css">
      
      
      
      
      
      
      
      
      
      

      <style> 
      /**
 * prism.js Github theme based on GitHub's theme.
 * @author Sam Clarke
 */
code[class*="language-"],
pre[class*="language-"] {
  color: #333;
  background: none;
  font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace;
  text-align: left;
  white-space: pre;
  word-spacing: normal;
  word-break: normal;
  word-wrap: normal;
  line-height: 1.4;

  -moz-tab-size: 8;
  -o-tab-size: 8;
  tab-size: 8;

  -webkit-hyphens: none;
  -moz-hyphens: none;
  -ms-hyphens: none;
  hyphens: none;
}

/* Code blocks */
pre[class*="language-"] {
  padding: .8em;
  overflow: auto;
  /* border: 1px solid #ddd; */
  border-radius: 3px;
  /* background: #fff; */
  background: #f5f5f5;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
  padding: .1em;
  border-radius: .3em;
  white-space: normal;
  background: #f5f5f5;
}

.token.comment,
.token.blockquote {
  color: #969896;
}

.token.cdata {
  color: #183691;
}

.token.doctype,
.token.punctuation,
.token.variable,
.token.macro.property {
  color: #333;
}

.token.operator,
.token.important,
.token.keyword,
.token.rule,
.token.builtin {
  color: #a71d5d;
}

.token.string,
.token.url,
.token.regex,
.token.attr-value {
  color: #183691;
}

.token.property,
.token.number,
.token.boolean,
.token.entity,
.token.atrule,
.token.constant,
.token.symbol,
.token.command,
.token.code {
  color: #0086b3;
}

.token.tag,
.token.selector,
.token.prolog {
  color: #63a35c;
}

.token.function,
.token.namespace,
.token.pseudo-element,
.token.class,
.token.class-name,
.token.pseudo-class,
.token.id,
.token.url-reference .token.variable,
.token.attr-name {
  color: #795da3;
}

.token.entity {
  cursor: help;
}

.token.title,
.token.title .token.punctuation {
  font-weight: bold;
  color: #1d3e81;
}

.token.list {
  color: #ed6a43;
}

.token.inserted {
  background-color: #eaffea;
  color: #55a532;
}

.token.deleted {
  background-color: #ffecec;
  color: #bd2c00;
}

.token.bold {
  font-weight: bold;
}

.token.italic {
  font-style: italic;
}


/* JSON */
.language-json .token.property {
  color: #183691;
}

.language-markup .token.tag .token.punctuation {
  color: #333;
}

/* CSS */
code.language-css,
.language-css .token.function {
  color: #0086b3;
}

/* YAML */
.language-yaml .token.atrule {
  color: #63a35c;
}

code.language-yaml {
  color: #183691;
}

/* Ruby */
.language-ruby .token.function {
  color: #333;
}

/* Markdown */
.language-markdown .token.url {
  color: #795da3;
}

/* Makefile */
.language-makefile .token.symbol {
  color: #795da3;
}

.language-makefile .token.variable {
  color: #183691;
}

.language-makefile .token.builtin {
  color: #0086b3;
}

/* Bash */
.language-bash .token.keyword {
  color: #0086b3;
}html body{font-family:"Helvetica Neue",Helvetica,"Segoe UI",Arial,freesans,sans-serif;font-size:16px;line-height:1.6;color:#333;background-color:#fff;overflow:initial;box-sizing:border-box;word-wrap:break-word}html body>:first-child{margin-top:0}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{line-height:1.2;margin-top:1em;margin-bottom:16px;color:#000}html body h1{font-size:2.25em;font-weight:300;padding-bottom:.3em}html body h2{font-size:1.75em;font-weight:400;padding-bottom:.3em}html body h3{font-size:1.5em;font-weight:500}html body h4{font-size:1.25em;font-weight:600}html body h5{font-size:1.1em;font-weight:600}html body h6{font-size:1em;font-weight:600}html body h1,html body h2,html body h3,html body h4,html body h5{font-weight:600}html body h5{font-size:1em}html body h6{color:#5c5c5c}html body strong{color:#000}html body del{color:#5c5c5c}html body a:not([href]){color:inherit;text-decoration:none}html body a{color:#08c;text-decoration:none}html body a:hover{color:#00a3f5;text-decoration:none}html body img{max-width:100%}html body>p{margin-top:0;margin-bottom:16px;word-wrap:break-word}html body>ul,html body>ol{margin-bottom:16px}html body ul,html body ol{padding-left:2em}html body ul.no-list,html body ol.no-list{padding:0;list-style-type:none}html body ul ul,html body ul ol,html body ol ol,html body ol ul{margin-top:0;margin-bottom:0}html body li{margin-bottom:0}html body li.task-list-item{list-style:none}html body li>p{margin-top:0;margin-bottom:0}html body .task-list-item-checkbox{margin:0 .2em .25em -1.8em;vertical-align:middle}html body .task-list-item-checkbox:hover{cursor:pointer}html body blockquote{margin:16px 0;font-size:inherit;padding:0 15px;color:#5c5c5c;border-left:4px solid #d6d6d6}html body blockquote>:first-child{margin-top:0}html body blockquote>:last-child{margin-bottom:0}html body hr{height:4px;margin:32px 0;background-color:#d6d6d6;border:0 none}html body table{margin:10px 0 15px 0;border-collapse:collapse;border-spacing:0;display:block;width:100%;overflow:auto;word-break:normal;word-break:keep-all}html body table th{font-weight:bold;color:#000}html body table td,html body table th{border:1px solid #d6d6d6;padding:6px 13px}html body dl{padding:0}html body dl dt{padding:0;margin-top:16px;font-size:1em;font-style:italic;font-weight:bold}html body dl dd{padding:0 16px;margin-bottom:16px}html body code{font-family:Menlo,Monaco,Consolas,'Courier New',monospace;font-size:.85em !important;color:#000;background-color:#f0f0f0;border-radius:3px;padding:.2em 0}html body code::before,html body code::after{letter-spacing:-0.2em;content:"\00a0"}html body pre>code{padding:0;margin:0;font-size:.85em !important;word-break:normal;white-space:pre;background:transparent;border:0}html body .highlight{margin-bottom:16px}html body .highlight pre,html body pre{padding:1em;overflow:auto;font-size:.85em !important;line-height:1.45;border:#d6d6d6;border-radius:3px}html body .highlight pre{margin-bottom:0;word-break:normal}html body pre code,html body pre tt{display:inline;max-width:initial;padding:0;margin:0;overflow:initial;line-height:inherit;word-wrap:normal;background-color:transparent;border:0}html body pre code:before,html body pre tt:before,html body pre code:after,html body pre tt:after{content:normal}html body p,html body blockquote,html body ul,html body ol,html body dl,html body pre{margin-top:0;margin-bottom:16px}html body kbd{color:#000;border:1px solid #d6d6d6;border-bottom:2px solid #c7c7c7;padding:2px 4px;background-color:#f0f0f0;border-radius:3px}@media print{html body{background-color:#fff}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{color:#000;page-break-after:avoid}html body blockquote{color:#5c5c5c}html body pre{page-break-inside:avoid}html body table{display:table}html body img{display:block;max-width:100%;max-height:100%}html body pre,html body code{word-wrap:break-word;white-space:pre}}.markdown-preview{width:100%;height:100%;box-sizing:border-box}.markdown-preview .pagebreak,.markdown-preview .newpage{page-break-before:always}.markdown-preview pre.line-numbers{position:relative;padding-left:3.8em;counter-reset:linenumber}.markdown-preview pre.line-numbers>code{position:relative}.markdown-preview pre.line-numbers .line-numbers-rows{position:absolute;pointer-events:none;top:1em;font-size:100%;left:0;width:3em;letter-spacing:-1px;border-right:1px solid #999;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.markdown-preview pre.line-numbers .line-numbers-rows>span{pointer-events:none;display:block;counter-increment:linenumber}.markdown-preview pre.line-numbers .line-numbers-rows>span:before{content:counter(linenumber);color:#999;display:block;padding-right:.8em;text-align:right}.markdown-preview .mathjax-exps .MathJax_Display{text-align:center !important}.markdown-preview:not([for="preview"]) .code-chunk .btn-group{display:none}.markdown-preview:not([for="preview"]) .code-chunk .status{display:none}.markdown-preview:not([for="preview"]) .code-chunk .output-div{margin-bottom:16px}.scrollbar-style::-webkit-scrollbar{width:8px}.scrollbar-style::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}.scrollbar-style::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,0.66);border:4px solid rgba(150,150,150,0.66);background-clip:content-box}html body[for="html-export"]:not([data-presentation-mode]){position:relative;width:100%;height:100%;top:0;left:0;margin:0;padding:0;overflow:auto}html body[for="html-export"]:not([data-presentation-mode]) .markdown-preview{position:relative;top:0}@media screen and (min-width:914px){html body[for="html-export"]:not([data-presentation-mode]) .markdown-preview{padding:2em calc(50% - 457px)}}@media screen and (max-width:914px){html body[for="html-export"]:not([data-presentation-mode]) .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for="html-export"]:not([data-presentation-mode]) .markdown-preview{font-size:14px !important;padding:1em}}@media print{html body[for="html-export"]:not([data-presentation-mode]) #sidebar-toc-btn{display:none}}html body[for="html-export"]:not([data-presentation-mode]) #sidebar-toc-btn{position:fixed;bottom:8px;left:8px;font-size:28px;cursor:pointer;color:inherit;z-index:99;width:32px;text-align:center;opacity:.4}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] #sidebar-toc-btn{opacity:1}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc{position:fixed;top:0;left:0;width:300px;height:100%;padding:32px 0 48px 0;font-size:14px;box-shadow:0 0 4px rgba(150,150,150,0.33);box-sizing:border-box;overflow:auto;background-color:inherit}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar{width:8px}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,0.66);border:4px solid rgba(150,150,150,0.66);background-clip:content-box}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc a{text-decoration:none}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc ul{padding:0 1.6em;margin-top:.8em}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc li{margin-bottom:.8em}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc ul{list-style-type:none}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{left:300px;width:calc(100% -  300px);padding:2em calc(50% - 457px -  150px);margin:0;box-sizing:border-box}@media screen and (max-width:1274px){html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{width:100%}}html body[for="html-export"]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .markdown-preview{left:50%;transform:translateX(-50%)}html body[for="html-export"]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .md-sidebar-toc{display:none}
/* Please visit the URL below for more information: */
/*   https://shd101wyy.github.io/markdown-preview-enhanced/#/customize-css */
 
      </style>
    </head>
    <body for="html-export">
      <div class="mume markdown-preview   ">
      <h1 class="mume-header" id="%E7%BB%A7%E6%89%BF">继承</h1>

<h2 class="mume-header" id="%E7%9B%AE%E6%A0%87">目标</h2>

<ul>
<li>单继承</li>
<li>多继承</li>
</ul>
<p><strong>面向对象三大特性</strong></p>
<ol>
<li><strong>封装</strong> 根据 <strong>职责</strong> 将 <strong>属性</strong> 和 <strong>方法</strong> <strong>封装</strong> 到一个抽象的 <strong>类</strong> 中</li>
<li><strong>继承</strong> <strong>实现代码的重用</strong>，相同的代码不需要重复的编写</li>
<li><strong>多态</strong> 不同的对象调用相同的方法，产生不同的执行结果，<strong>增加代码的灵活度</strong></li>
</ol>
<h2 class="mume-header" id="01-%E5%8D%95%E7%BB%A7%E6%89%BF">01. 单继承</h2>

<h3 class="mume-header" id="11-%E7%BB%A7%E6%89%BF%E7%9A%84%E6%A6%82%E5%BF%B5-%E8%AF%AD%E6%B3%95%E5%92%8C%E7%89%B9%E7%82%B9">1.1 继承的概念、语法和特点</h3>

<p><strong>继承的概念</strong>：<strong>子类</strong> 拥有 <strong>父类</strong> 的所有 <strong>方法</strong> 和 <strong>属性</strong></p>
<p><img src="media/15006307099794/011_%E7%BB%A7%E6%89%BF%E5%AF%B9%E6%AF%94%E5%9B%BE%E7%A4%BA.png" alt="011_&#x7EE7;&#x627F;&#x5BF9;&#x6BD4;&#x56FE;&#x793A;"></p>
<h4 class="mume-header" id="1-%E7%BB%A7%E6%89%BF%E7%9A%84%E8%AF%AD%E6%B3%95">1) 继承的语法</h4>

<pre data-role="codeBlock" data-info="python" class="language-python"><span class="token keyword">class</span> 类名<span class="token punctuation">(</span>父类名<span class="token punctuation">)</span><span class="token punctuation">:</span>

    <span class="token keyword">pass</span>
</pre><ul>
<li><strong>子类</strong> 继承自 <strong>父类</strong>，可以直接 <strong>享受</strong> 父类中已经封装好的方法，不需要再次开发</li>
<li><strong>子类</strong> 中应该根据 <strong>职责</strong>，封装 <strong>子类特有的</strong> <strong>属性和方法</strong></li>
</ul>
<h4 class="mume-header" id="2-%E4%B8%93%E4%B8%9A%E6%9C%AF%E8%AF%AD">2) 专业术语</h4>

<ul>
<li><code>Dog</code> 类是 <code>Animal</code> 类的<strong>子类</strong>，<code>Animal</code> 类是 <code>Dog</code> 类的<strong>父类</strong>，<code>Dog</code> 类从 <code>Animal</code> 类<strong>继承</strong></li>
<li><code>Dog</code> 类是 <code>Animal</code> 类的<strong>派生类</strong>，<code>Animal</code> 类是 <code>Dog</code> 类的<strong>基类</strong>，<code>Dog</code> 类从 <code>Animal</code> 类<strong>派生</strong></li>
</ul>
<h4 class="mume-header" id="3-%E7%BB%A7%E6%89%BF%E7%9A%84%E4%BC%A0%E9%80%92%E6%80%A7">3) 继承的传递性</h4>

<ul>
<li><code>C</code> 类从 <code>B</code> 类继承，<code>B</code> 类又从 <code>A</code> 类继承</li>
<li>那么 <code>C</code> 类就具有 <code>B</code> 类和 <code>A</code> 类的所有属性和方法</li>
</ul>
<p><strong>子类</strong> 拥有 <strong>父类</strong> 以及 <strong>父类的父类</strong> 中封装的所有 <strong>属性</strong> 和 <strong>方法</strong></p>
<p><strong>提问</strong></p>
<p><strong>哮天犬</strong> 能够调用 <code>Cat</code> 类中定义的 <code>catch</code> 方法吗？</p>
<p><strong>答案</strong></p>
<p><strong>不能</strong>，因为 <strong>哮天犬</strong> 和 <code>Cat</code> 之间没有 <strong>继承</strong> 关系</p>
<h3 class="mume-header" id="12-%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99">1.2 方法的重写</h3>

<ul>
<li><strong>子类</strong> 拥有 <strong>父类</strong> 的所有 <strong>方法</strong> 和 <strong>属性</strong></li>
<li><strong>子类</strong> 继承自 <strong>父类</strong>，可以直接 <strong>享受</strong> 父类中已经封装好的方法，不需要再次开发</li>
</ul>
<p><strong>应用场景</strong></p>
<ul>
<li>当 <strong>父类</strong> 的方法实现不能满足子类需求时，可以对方法进行 <strong>重写(override)</strong></li>
</ul>
<p><img src="media/15006307099794/012_%E7%BB%A7%E6%89%BF%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99.png" alt="012_&#x7EE7;&#x627F;&#x65B9;&#x6CD5;&#x7684;&#x91CD;&#x5199;-w203"></p>
<p><strong>重写</strong> 父类方法有两种情况：</p>
<ol>
<li><strong>覆盖</strong> 父类的方法</li>
<li>对父类方法进行 <strong>扩展</strong></li>
</ol>
<h4 class="mume-header" id="1-%E8%A6%86%E7%9B%96%E7%88%B6%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95">1) 覆盖父类的方法</h4>

<ul>
<li>如果在开发中，<strong>父类的方法实现</strong> 和 <strong>子类的方法实现</strong>，<strong>完全不同</strong></li>
<li>就可以使用 <strong>覆盖</strong> 的方式，<strong>在子类中</strong> <strong>重新编写</strong> 父类的方法实现</li>
</ul>
<blockquote>
<p>具体的实现方式，就相当于在 <strong>子类中</strong> 定义了一个 <strong>和父类同名的方法并且实现</strong></p>
</blockquote>
<p>重写之后，在运行时，<strong>只会调用</strong> 子类中重写的方法，而不再会调用 <strong>父类封装的方法</strong></p>
<h4 class="mume-header" id="2-%E5%AF%B9%E7%88%B6%E7%B1%BB%E6%96%B9%E6%B3%95%E8%BF%9B%E8%A1%8C-%E6%89%A9%E5%B1%95">2) 对父类方法进行 <strong>扩展</strong></h4>

<ul>
<li>如果在开发中，<strong>子类的方法实现</strong> 中 <strong>包含</strong> <strong>父类的方法实现</strong>
<ul>
<li><strong>父类原本封装的方法实现</strong> 是 <strong>子类方法的一部分</strong></li>
</ul>
</li>
<li>就可以使用 <strong>扩展</strong> 的方式
<ol>
<li><strong>在子类中</strong> <strong>重写</strong> 父类的方法</li>
<li>在需要的位置使用 <code>super().父类方法</code> 来调用父类方法的执行</li>
<li>代码其他的位置针对子类的需求，编写 <strong>子类特有的代码实现</strong></li>
</ol>
</li>
</ul>
<h5 class="mume-header" id="%E5%85%B3%E4%BA%8E-super">关于 <code>super</code></h5>

<ul>
<li>在 <code>Python</code> 中 <code>super</code> 是一个 <strong>特殊的类</strong></li>
<li><code>super()</code> 就是使用 <code>super</code> 类创建出来的对象</li>
<li><strong>最常</strong> 使用的场景就是在 <strong>重写父类方法时</strong>，调用 <strong>在父类中封装的方法实现</strong></li>
</ul>
<h5 class="mume-header" id="%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E6%96%B9%E6%B3%95%E7%9A%84%E5%8F%A6%E5%A4%96%E4%B8%80%E7%A7%8D%E6%96%B9%E5%BC%8F%E7%9F%A5%E9%81%93">调用父类方法的另外一种方式（知道）</h5>

<blockquote>
<p>在 <code>Python 2.x</code> 时，如果需要调用父类的方法，还可以使用以下方式：</p>
</blockquote>
<pre data-role="codeBlock" data-info="python" class="language-python">父类名<span class="token punctuation">.</span>方法<span class="token punctuation">(</span>self<span class="token punctuation">)</span>
</pre><ul>
<li>这种方式，目前在 <code>Python 3.x</code> 还支持这种方式</li>
<li>这种方法 <strong>不推荐使用</strong>，因为一旦 <strong>父类发生变化</strong>，方法调用位置的 <strong>类名</strong> 同样需要修改</li>
</ul>
<p><strong>提示</strong></p>
<ul>
<li>在开发时，<code>父类名</code> 和 <code>super()</code> 两种方式不要混用</li>
<li>如果使用 <strong>当前子类名</strong> 调用方法，会形成递归调用，<strong>出现死循环</strong></li>
</ul>
<h3 class="mume-header" id="13-%E7%88%B6%E7%B1%BB%E7%9A%84-%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7-%E5%92%8C-%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95">1.3 父类的 私有属性 和 私有方法</h3>

<ol>
<li><strong>子类对象</strong> <strong>不能</strong> 在自己的方法内部，<strong>直接</strong> 访问 父类的 <strong>私有属性</strong> 或 <strong>私有方法</strong></li>
<li><strong>子类对象</strong> 可以通过 <strong>父类</strong> 的 <strong>公有方法</strong> <strong>间接</strong> 访问到 <strong>私有属性</strong> 或 <strong>私有方法</strong></li>
</ol>
<blockquote>
<ul>
<li><strong>私有属性、方法</strong> 是对象的隐私，不对外公开，<strong>外界</strong> 以及 <strong>子类</strong> 都不能直接访问</li>
<li><strong>私有属性、方法</strong> 通常用于做一些内部的事情</li>
</ul>
</blockquote>
<p><strong>示例</strong></p>
<p><img src="media/15006307099794/013_%E7%88%B6%E7%B1%BB%E7%9A%84%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7%E5%92%8C%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95.png" alt="013_&#x7236;&#x7C7B;&#x7684;&#x79C1;&#x6709;&#x5C5E;&#x6027;&#x548C;&#x79C1;&#x6709;&#x65B9;&#x6CD5;-w220"></p>
<ul>
<li><code>B</code> 的对象不能直接访问 <code>__num2</code> 属性</li>
<li><code>B</code> 的对象不能在 <code>demo</code> 方法内访问 <code>__num2</code> 属性</li>
<li><code>B</code> 的对象可以在 <code>demo</code> 方法内，调用父类的 <code>test</code> 方法</li>
<li>父类的 <code>test</code> 方法内部，能够访问 <code>__num2</code> 属性和 <code>__test</code> 方法</li>
</ul>
<h2 class="mume-header" id="02-%E5%A4%9A%E7%BB%A7%E6%89%BF">02. 多继承</h2>

<p><strong>概念</strong></p>
<ul>
<li><strong>子类</strong> 可以拥有 <strong>多个父类</strong>，并且具有 <strong>所有父类</strong> 的 <strong>属性</strong> 和 <strong>方法</strong></li>
<li>例如：<strong>孩子</strong> 会继承自己 <strong>父亲</strong> 和 <strong>母亲</strong> 的 <strong>特性</strong></li>
</ul>
<p><img src="media/15006307099794/014_%E5%A4%9A%E7%BB%A7%E6%89%BF.png" alt="014_&#x591A;&#x7EE7;&#x627F;-w384"></p>
<p><strong>语法</strong></p>
<pre data-role="codeBlock" data-info="python" class="language-python"><span class="token keyword">class</span> 子类名<span class="token punctuation">(</span>父类名<span class="token number">1</span><span class="token punctuation">,</span> 父类名<span class="token number">2</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>
    <span class="token keyword">pass</span>
</pre><h3 class="mume-header" id="21-%E5%A4%9A%E7%BB%A7%E6%89%BF%E7%9A%84%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">2.1 多继承的使用注意事项</h3>

<p><strong>问题的提出</strong></p>
<ul>
<li>如果 <strong>不同的父类</strong> 中存在 <strong>同名的方法</strong>，<strong>子类对象</strong> 在调用方法时，会调用 <strong>哪一个父类中</strong>的方法呢？</li>
</ul>
<blockquote>
<p>提示：<strong>开发时，应该尽量避免这种容易产生混淆的情况！</strong> —— 如果 <strong>父类之间</strong> 存在 <strong>同名的属性或者方法</strong>，应该 <strong>尽量避免</strong> 使用多继承</p>
</blockquote>
<p><img src="media/15006307099794/015_%E5%A4%9A%E7%BB%A7%E6%89%BFII.png" alt="015_&#x591A;&#x7EE7;&#x627F;II-w384"></p>
<h4 class="mume-header" id="python-%E4%B8%AD%E7%9A%84-mro-%E6%96%B9%E6%B3%95%E6%90%9C%E7%B4%A2%E9%A1%BA%E5%BA%8F%E7%9F%A5%E9%81%93">Python 中的 MRO —— 方法搜索顺序（知道）</h4>

<ul>
<li><code>Python</code> 中针对 <strong>类</strong> 提供了一个 <strong>内置属性</strong> <code>__mro__</code> 可以查看 <strong>方法</strong> 搜索顺序</li>
<li>MRO 是 <code>method resolution order</code>，主要用于 <strong>在多继承时判断 方法、属性 的调用 路径</strong></li>
</ul>
<pre data-role="codeBlock" data-info="python" class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>C<span class="token punctuation">.</span>__mro__<span class="token punctuation">)</span>
</pre><p><strong>输出结果</strong></p>
<pre data-role="codeBlock" data-info="" class="language-"><code>(&lt;class &apos;__main__.C&apos;&gt;, &lt;class &apos;__main__.A&apos;&gt;, &lt;class &apos;__main__.B&apos;&gt;, &lt;class &apos;object&apos;&gt;)
</code></pre><ul>
<li>在搜索方法时，是按照 <code>__mro__</code> 的输出结果 <strong>从左至右</strong> 的顺序查找的</li>
<li>如果在当前类中 <strong>找到方法，就直接执行，不再搜索</strong></li>
<li>如果 <strong>没有找到，就查找下一个类</strong> 中是否有对应的方法，<strong>如果找到，就直接执行，不再搜索</strong></li>
<li>如果找到最后一个类，还没有找到方法，程序报错</li>
</ul>
<h3 class="mume-header" id="22-%E6%96%B0%E5%BC%8F%E7%B1%BB%E4%B8%8E%E6%97%A7%E5%BC%8F%E7%BB%8F%E5%85%B8%E7%B1%BB">2.2 新式类与旧式（经典）类</h3>

<blockquote>
<p><code>object</code> 是 <code>Python</code> 为所有对象提供的 <strong>基类</strong>，提供有一些内置的属性和方法，可以使用 <code>dir</code> 函数查看</p>
</blockquote>
<ul>
<li>
<p><strong>新式类</strong>：以 <code>object</code> 为基类的类，<strong>推荐使用</strong></p>
</li>
<li>
<p><strong>经典类</strong>：不以 <code>object</code> 为基类的类，<strong>不推荐使用</strong></p>
</li>
<li>
<p>在 <code>Python 3.x</code> 中定义类时，如果没有指定父类，会 <strong>默认使用</strong> <code>object</code> 作为该类的 <strong>基类</strong> —— <code>Python 3.x</code> 中定义的类都是 <strong>新式类</strong></p>
</li>
<li>
<p>在 <code>Python 2.x</code> 中定义类时，如果没有指定父类，则不会以 <code>object</code> 作为 <strong>基类</strong></p>
</li>
</ul>
<blockquote>
<p><strong>新式类</strong> 和 <strong>经典类</strong> 在多继承时 —— <strong>会影响到方法的搜索顺序</strong></p>
</blockquote>
<p>为了保证编写的代码能够同时在 <code>Python 2.x</code> 和 <code>Python 3.x</code> 运行！<br>
今后在定义类时，<strong>如果没有父类，建议统一继承自 <code>object</code></strong></p>
<pre data-role="codeBlock" data-info="python" class="language-python"><span class="token keyword">class</span> 类名<span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">pass</span>
</pre><h1 class="mume-header" id="%E5%A4%9A%E6%80%81">多态</h1>

<h2 class="mume-header" id="%E7%9B%AE%E6%A0%87-1">目标</h2>

<ul>
<li>多态</li>
</ul>
<p><strong>面向对象三大特性</strong></p>
<ol>
<li>
<p><strong>封装</strong> 根据 <strong>职责</strong> 将 <strong>属性</strong> 和 <strong>方法</strong> <strong>封装</strong> 到一个抽象的 <strong>类</strong> 中</p>
<ul>
<li>定义类的准则</li>
</ul>
</li>
<li>
<p><strong>继承</strong> <strong>实现代码的重用</strong>，相同的代码不需要重复的编写</p>
<ul>
<li>设计类的技巧</li>
<li>子类针对自己特有的需求，编写特定的代码</li>
</ul>
</li>
<li>
<p><strong>多态</strong> 不同的 <strong>子类对象</strong> 调用相同的 <strong>父类方法</strong>，产生不同的执行结果</p>
<ul>
<li><strong>多态</strong> 可以 <strong>增加代码的灵活度</strong></li>
<li>以 <strong>继承</strong> 和 <strong>重写父类方法</strong> 为前提</li>
<li>是调用方法的技巧，<strong>不会影响到类的内部设计</strong></li>
</ul>
<p><img src="media/15012536156932/016_%E5%A4%9A%E6%80%81%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="016_&#x591A;&#x6001;&#x793A;&#x610F;&#x56FE;-w384"></p>
</li>
</ol>
<h2 class="mume-header" id="%E5%A4%9A%E6%80%81%E6%A1%88%E4%BE%8B%E6%BC%94%E7%BB%83">多态案例演练</h2>

<p><strong>需求</strong></p>
<ol>
<li>在 <code>Dog</code> 类中封装方法 <code>game</code>
<ul>
<li>普通狗只是简单的玩耍</li>
</ul>
</li>
<li>定义 <code>XiaoTianDog</code> 继承自 <code>Dog</code>，并且重写 <code>game</code> 方法
<ul>
<li>哮天犬需要在天上玩耍</li>
</ul>
</li>
<li>定义 <code>Person</code> 类，并且封装一个 <strong>和狗玩</strong> 的方法
<ul>
<li>在方法内部，直接让 <strong>狗对象</strong> 调用 <code>game</code> 方法</li>
</ul>
</li>
</ol>
<p><img src="media/15012536156932/016_%E5%A4%9A%E6%80%81.png" alt="016_&#x591A;&#x6001;-w701"></p>
<p><strong>案例小结</strong></p>
<ul>
<li><code>Person</code> 类中只需要让 <strong>狗对象</strong> 调用 <code>game</code> 方法，而不关心具体是 <strong>什么狗</strong>
<ul>
<li><code>game</code> 方法是在 <code>Dog</code> 父类中定义的</li>
</ul>
</li>
<li>在程序执行时，传入不同的 <strong>狗对象</strong> 实参，就会产生不同的执行效果</li>
</ul>
<blockquote>
<p><strong>多态</strong> 更容易编写出出通用的代码，做出通用的编程，以适应需求的不断变化！</p>
</blockquote>
<pre data-role="codeBlock" data-info="python" class="language-python"><span class="token keyword">class</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>

    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>name <span class="token operator">=</span> name

    <span class="token keyword">def</span> <span class="token function">game</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"%s 蹦蹦跳跳的玩耍..."</span> <span class="token operator">%</span> self<span class="token punctuation">.</span>name<span class="token punctuation">)</span>


<span class="token keyword">class</span> <span class="token class-name">XiaoTianDog</span><span class="token punctuation">(</span>Dog<span class="token punctuation">)</span><span class="token punctuation">:</span>

    <span class="token keyword">def</span> <span class="token function">game</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"%s 飞到天上去玩耍..."</span> <span class="token operator">%</span> self<span class="token punctuation">.</span>name<span class="token punctuation">)</span>


<span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>

    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>name <span class="token operator">=</span> name

    <span class="token keyword">def</span> <span class="token function">game_with_dog</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> dog<span class="token punctuation">)</span><span class="token punctuation">:</span>

        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"%s 和 %s 快乐的玩耍..."</span> <span class="token operator">%</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>name<span class="token punctuation">,</span> dog<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span>

        <span class="token comment"># 让狗玩耍</span>
        dog<span class="token punctuation">.</span>game<span class="token punctuation">(</span><span class="token punctuation">)</span>


<span class="token comment"># 1. 创建一个狗对象</span>
<span class="token comment"># wangcai = Dog("旺财")</span>
wangcai <span class="token operator">=</span> XiaoTianDog<span class="token punctuation">(</span><span class="token string">"飞天旺财"</span><span class="token punctuation">)</span>

<span class="token comment"># 2. 创建一个小明对象</span>
xiaoming <span class="token operator">=</span> Person<span class="token punctuation">(</span><span class="token string">"小明"</span><span class="token punctuation">)</span>

<span class="token comment"># 3. 让小明调用和狗玩的方法</span>
xiaoming<span class="token punctuation">.</span>game_with_dog<span class="token punctuation">(</span>wangcai<span class="token punctuation">)</span>
        
</pre><h1 class="mume-header" id="%E7%B1%BB%E5%B1%9E%E6%80%A7%E5%92%8C%E7%B1%BB%E6%96%B9%E6%B3%95">类属性和类方法</h1>

<h2 class="mume-header" id="%E7%9B%AE%E6%A0%87-2">目标</h2>

<ul>
<li>类的结构</li>
<li>类属性和实例属性</li>
<li>类方法和静态方法</li>
</ul>
<h2 class="mume-header" id="01-%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84">01. 类的结构</h2>

<h3 class="mume-header" id="11-%E6%9C%AF%E8%AF%AD-%E5%AE%9E%E4%BE%8B">1.1 术语 —— 实例</h3>

<ol>
<li>使用面相对象开发，<strong>第 1 步</strong> 是设计 <strong>类</strong></li>
<li>使用 <strong>类名()</strong> 创建对象，<strong>创建对象</strong> 的动作有两步：
<ul>
<li>
<ol>
<li>在内存中为对象 <strong>分配空间</strong></li>
</ol>
</li>
<li>
<ol start="2">
<li>调用初始化方法 <code>__init__</code> 为 <strong>对象初始化</strong></li>
</ol>
</li>
</ul>
</li>
<li>对象创建后，<strong>内存</strong> 中就有了一个对象的 <strong>实实在在</strong> 的存在 —— <strong>实例</strong></li>
</ol>
<p><img src="media/15016413127744/017_%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BEI.png" alt="017_&#x7C7B;&#x7684;&#x7ED3;&#x6784;&#x793A;&#x610F;&#x56FE;I-w473"></p>
<p>因此，通常也会把：</p>
<ol>
<li>创建出来的 <strong>对象</strong> 叫做 <strong>类</strong> 的 <strong>实例</strong></li>
<li>创建对象的 <strong>动作</strong> 叫做 <strong>实例化</strong></li>
<li><strong>对象的属性</strong> 叫做 <strong>实例属性</strong></li>
<li><strong>对象调用的方法</strong> 叫做 <strong>实例方法</strong></li>
</ol>
<p>在程序执行时：</p>
<ol>
<li>对象各自拥有自己的 <strong>实例属性</strong></li>
<li>调用对象方法，可以通过 <code>self.</code>
<ul>
<li>访问自己的属性</li>
<li>调用自己的方法</li>
</ul>
</li>
</ol>
<p><strong>结论</strong></p>
<ul>
<li><strong>每一个对象</strong> 都有自己 <strong>独立的内存空间</strong>，<strong>保存各自不同的属性</strong></li>
<li><strong>多个对象的方法</strong>，<strong>在内存中只有一份</strong>，在调用方法时，<strong>需要把对象的引用</strong> 传递到方法内部</li>
</ul>
<h3 class="mume-header" id="12-%E7%B1%BB%E6%98%AF%E4%B8%80%E4%B8%AA%E7%89%B9%E6%AE%8A%E7%9A%84%E5%AF%B9%E8%B1%A1">1.2 类是一个特殊的对象</h3>

<blockquote>
<p><code>Python</code> 中 <strong>一切皆对象</strong>：</p>
<ul>
<li><code>class AAA:</code> 定义的类属于 <strong>类对象</strong></li>
<li><code>obj1 = AAA()</code> 属于 <strong>实例对象</strong></li>
</ul>
</blockquote>
<ul>
<li>在程序运行时，<strong>类</strong> 同样 <strong>会被加载到内存</strong></li>
<li>在 <code>Python</code> 中，<strong>类</strong> 是一个特殊的对象 —— <strong>类对象</strong></li>
<li>在程序运行时，<strong>类对象</strong> 在内存中 <strong>只有一份</strong>，使用 <strong>一个类</strong> 可以创建出 <strong>很多个对象实例</strong></li>
<li>除了封装 <strong>实例</strong> 的 <strong>属性</strong> 和 <strong>方法</strong>外，<strong>类对象</strong> 还可以拥有自己的 <strong>属性</strong> 和 <strong>方法</strong>
<ol>
<li><strong>类属性</strong></li>
<li><strong>类方法</strong></li>
</ol>
</li>
<li>通过 <strong>类名.</strong> 的方式可以 <strong>访问类的属性</strong> 或者 <strong>调用类的方法</strong></li>
</ul>
<p><img src="media/15016413127744/017_%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BEII.png" alt="017_&#x7C7B;&#x7684;&#x7ED3;&#x6784;&#x793A;&#x610F;&#x56FE;II-w545"></p>
<h2 class="mume-header" id="02-%E7%B1%BB%E5%B1%9E%E6%80%A7%E5%92%8C%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7">02. 类属性和实例属性</h2>

<h3 class="mume-header" id="21-%E6%A6%82%E5%BF%B5%E5%92%8C%E4%BD%BF%E7%94%A8">2.1 概念和使用</h3>

<ul>
<li><strong>类属性</strong> 就是给 <strong>类对象</strong> 中定义的 <strong>属性</strong></li>
<li>通常用来记录 <strong>与这个类相关</strong> 的特征</li>
<li><strong>类属性</strong> <strong>不会用于</strong>记录 <strong>具体对象的特征</strong></li>
</ul>
<p><strong>示例需求</strong></p>
<ul>
<li>定义一个 <strong>工具类</strong></li>
<li>每件工具都有自己的 <code>name</code></li>
<li><strong>需求</strong> —— 知道使用这个类，创建了多少个工具对象？</li>
</ul>
<p><img src="media/15016413127744/018_%E7%B1%BB%E5%B1%9E%E6%80%A7%E6%A1%88%E4%BE%8BI.png" alt="018_&#x7C7B;&#x5C5E;&#x6027;&#x6848;&#x4F8B;I-w263"></p>
<pre data-role="codeBlock" data-info="python" class="language-python"><span class="token keyword">class</span> <span class="token class-name">Tool</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>

    <span class="token comment"># 使用赋值语句，定义类属性，记录创建工具对象的总数</span>
    count <span class="token operator">=</span> <span class="token number">0</span>

    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>name <span class="token operator">=</span> name

        <span class="token comment"># 针对类属性做一个计数+1</span>
        Tool<span class="token punctuation">.</span>count <span class="token operator">+=</span> <span class="token number">1</span>


<span class="token comment"># 创建工具对象</span>
tool1 <span class="token operator">=</span> Tool<span class="token punctuation">(</span><span class="token string">"斧头"</span><span class="token punctuation">)</span>
tool2 <span class="token operator">=</span> Tool<span class="token punctuation">(</span><span class="token string">"榔头"</span><span class="token punctuation">)</span>
tool3 <span class="token operator">=</span> Tool<span class="token punctuation">(</span><span class="token string">"铁锹"</span><span class="token punctuation">)</span>

<span class="token comment"># 知道使用 Tool 类到底创建了多少个对象?</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"现在创建了 %d 个工具"</span> <span class="token operator">%</span> Tool<span class="token punctuation">.</span>count<span class="token punctuation">)</span>

</pre><h3 class="mume-header" id="22-%E5%B1%9E%E6%80%A7%E7%9A%84%E8%8E%B7%E5%8F%96%E6%9C%BA%E5%88%B6%E7%A7%91%E6%99%AE">2.2 属性的获取机制（科普）</h3>

<ul>
<li>在 <code>Python</code> 中 <strong>属性的获取</strong> 存在一个 <strong>向上查找机制</strong></li>
</ul>
<p><img src="media/15016413127744/019_%E9%80%9A%E8%BF%87%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE%E7%B1%BB%E5%B1%9E%E6%80%A7.png" alt="019_&#x901A;&#x8FC7;&#x5BF9;&#x8C61;&#x8BBF;&#x95EE;&#x7C7B;&#x5C5E;&#x6027;-w779"></p>
<ul>
<li>因此，要访问类属性有两种方式：
<ol>
<li><strong>类名.类属性</strong></li>
<li><strong>对象.类属性</strong> （不推荐）</li>
</ol>
</li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li>如果使用 <code>对象.类属性 = 值</code> 赋值语句，只会 <strong>给对象添加一个属性</strong>，而不会影响到 <strong>类属性的值</strong></li>
</ul>
<h2 class="mume-header" id="03-%E7%B1%BB%E6%96%B9%E6%B3%95%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95">03. 类方法和静态方法</h2>

<h3 class="mume-header" id="31-%E7%B1%BB%E6%96%B9%E6%B3%95">3.1 类方法</h3>

<ul>
<li><strong>类属性</strong> 就是针对 <strong>类对象</strong> 定义的属性
<ul>
<li>使用 <strong>赋值语句</strong> 在 <code>class</code> 关键字下方可以定义 <strong>类属性</strong></li>
<li><strong>类属性</strong> 用于记录 <strong>与这个类相关</strong> 的特征</li>
</ul>
</li>
<li><strong>类方法</strong> 就是针对 <strong>类对象</strong> 定义的方法
<ul>
<li>在 <strong>类方法</strong> 内部可以直接访问 <strong>类属性</strong> 或者调用其他的 <strong>类方法</strong></li>
</ul>
</li>
</ul>
<p><strong>语法如下</strong></p>
<pre data-role="codeBlock" data-info="python" class="language-python">@<span class="token builtin">classmethod</span>
<span class="token keyword">def</span> 类方法名<span class="token punctuation">(</span>cls<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">pass</span>
</pre><ul>
<li>类方法需要用 <strong>修饰器</strong> <code>@classmethod</code> 来标识，<strong>告诉解释器这是一个类方法</strong></li>
<li>类方法的 <strong>第一个参数</strong> 应该是 <code>cls</code>
<ul>
<li>由 <strong>哪一个类</strong> 调用的方法，方法内的 <code>cls</code> 就是 <strong>哪一个类的引用</strong></li>
<li>这个参数和 <strong>实例方法</strong> 的第一个参数是 <code>self</code> 类似</li>
<li><strong>提示</strong> 使用其他名称也可以，不过习惯使用 <code>cls</code></li>
</ul>
</li>
</ul>
<ol start="3">
<li>通过 <strong>类名.</strong> 调用 <strong>类方法</strong>，<strong>调用方法时</strong>，不需要传递 <code>cls</code> 参数</li>
<li><strong>在方法内部</strong>
<ul>
<li>可以通过 <code>cls.</code> <strong>访问类的属性</strong></li>
<li>也可以通过 <code>cls.</code> <strong>调用其他的类方法</strong></li>
</ul>
</li>
</ol>
<p><strong>示例需求</strong></p>
<ul>
<li>定义一个 <strong>工具类</strong></li>
<li>每件工具都有自己的 <code>name</code></li>
<li><strong>需求</strong> —— 在 <strong>类</strong> 封装一个 <code>show_tool_count</code> 的类方法，输出使用当前这个类，创建的对象个数</li>
</ul>
<p><img src="media/15016413127744/020_%E7%B1%BB%E6%96%B9%E6%B3%95%E6%A1%88%E4%BE%8B.png" alt="020_&#x7C7B;&#x65B9;&#x6CD5;&#x6848;&#x4F8B;-w263"></p>
<pre data-role="codeBlock" data-info="python" class="language-python">@<span class="token builtin">classmethod</span>
<span class="token keyword">def</span> <span class="token function">show_tool_count</span><span class="token punctuation">(</span>cls<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""显示工具对象的总数"""</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"工具对象的总数 %d"</span> <span class="token operator">%</span> cls<span class="token punctuation">.</span>count<span class="token punctuation">)</span>
</pre><blockquote>
<p>在类方法内部，可以直接使用 <code>cls</code> 访问 <strong>类属性</strong> 或者 <strong>调用类方法</strong></p>
</blockquote>
<h3 class="mume-header" id="32-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95">3.2 静态方法</h3>

<ul>
<li>
<p>在开发时，如果需要在 <strong>类</strong> 中封装一个方法，这个方法：</p>
<ul>
<li>既 <strong>不需要</strong> 访问 <strong>实例属性</strong> 或者调用 <strong>实例方法</strong></li>
<li>也 <strong>不需要</strong> 访问 <strong>类属性</strong> 或者调用 <strong>类方法</strong></li>
</ul>
</li>
<li>
<p>这个时候，可以把这个方法封装成一个 <strong>静态方法</strong></p>
</li>
</ul>
<p><strong>语法如下</strong></p>
<pre data-role="codeBlock" data-info="python" class="language-python">@<span class="token builtin">staticmethod</span>
<span class="token keyword">def</span> 静态方法名<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">pass</span>
</pre><ul>
<li><strong>静态方法</strong> 需要用 <strong>修饰器</strong> <code>@staticmethod</code> 来标识，<strong>告诉解释器这是一个静态方法</strong></li>
<li>通过 <strong>类名.</strong> 调用 <strong>静态方法</strong></li>
</ul>
<pre data-role="codeBlock" data-info="python" class="language-python"><span class="token keyword">class</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    
    <span class="token comment"># 狗对象计数</span>
    dog_count <span class="token operator">=</span> <span class="token number">0</span>
    
    @<span class="token builtin">staticmethod</span>
    <span class="token keyword">def</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        
        <span class="token comment"># 不需要访问实例属性也不需要访问类属性的方法</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"狗在跑..."</span><span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>name <span class="token operator">=</span> name
        
</pre><h3 class="mume-header" id="33-%E6%96%B9%E6%B3%95%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B">3.3 方法综合案例</h3>

<p><strong>需求</strong></p>
<ol>
<li>设计一个 <code>Game</code> 类</li>
<li>属性：
<ul>
<li>定义一个 <strong>类属性</strong> <code>top_score</code> 记录游戏的 <strong>历史最高分</strong></li>
<li>定义一个 <strong>实例属性</strong> <code>player_name</code> 记录 <strong>当前游戏的玩家姓名</strong></li>
</ul>
</li>
<li>方法：
<ul>
<li><strong>静态方法</strong> <code>show_help</code> 显示游戏帮助信息</li>
<li><strong>类方法</strong> <code>show_top_score</code> 显示历史最高分</li>
<li><strong>实例方法</strong> <code>start_game</code> 开始当前玩家的游戏</li>
</ul>
</li>
<li>主程序步骤
<ul>
<li>
<ol>
<li>查看帮助信息</li>
</ol>
</li>
<li>
<ol start="2">
<li>查看历史最高分</li>
</ol>
</li>
<li>
<ol start="3">
<li>创建游戏对象，开始游戏</li>
</ol>
</li>
</ul>
</li>
</ol>
<p><img src="media/15016413127744/021_%E6%96%B9%E6%B3%95%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B.png" alt="021_&#x65B9;&#x6CD5;&#x7EFC;&#x5408;&#x6848;&#x4F8B;-w351"></p>
<h4 class="mume-header" id="%E6%A1%88%E4%BE%8B%E5%B0%8F%E7%BB%93">案例小结</h4>

<ol>
<li><strong>实例方法</strong> —— 方法内部需要访问 <strong>实例属性</strong>
<ul>
<li><strong>实例方法</strong> 内部可以使用 <strong>类名.</strong> 访问类属性</li>
</ul>
</li>
<li><strong>类方法</strong> —— 方法内部 <strong>只</strong> 需要访问 <strong>类属性</strong></li>
<li><strong>静态方法</strong> —— 方法内部，不需要访问 <strong>实例属性</strong> 和 <strong>类属性</strong></li>
</ol>
<p><strong>提问</strong></p>
<p>如果方法内部 即需要访问 <strong>实例属性</strong>，又需要访问 <strong>类属性</strong>，应该定义成什么方法？</p>
<p><strong>答案</strong></p>
<ul>
<li>应该定义 <strong>实例方法</strong></li>
<li>因为，<strong>类只有一个</strong>，在 <strong>实例方法</strong> 内部可以使用 <strong>类名.</strong> 访问类属性</li>
</ul>
<pre data-role="codeBlock" data-info="python" class="language-python"><span class="token keyword">class</span> <span class="token class-name">Game</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>

    <span class="token comment"># 游戏最高分，类属性</span>
    top_score <span class="token operator">=</span> <span class="token number">0</span>

    @<span class="token builtin">staticmethod</span>
    <span class="token keyword">def</span> <span class="token function">show_help</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"帮助信息：让僵尸走进房间"</span><span class="token punctuation">)</span>
        
    @<span class="token builtin">classmethod</span>
    <span class="token keyword">def</span> <span class="token function">show_top_score</span><span class="token punctuation">(</span>cls<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"游戏最高分是 %d"</span> <span class="token operator">%</span> cls<span class="token punctuation">.</span>top_score<span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> player_name<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>player_name <span class="token operator">=</span> player_name

    <span class="token keyword">def</span> <span class="token function">start_game</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"[%s] 开始游戏..."</span> <span class="token operator">%</span> self<span class="token punctuation">.</span>player_name<span class="token punctuation">)</span>
        
        <span class="token comment"># 使用类名.修改历史最高分</span>
        Game<span class="token punctuation">.</span>top_score <span class="token operator">=</span> <span class="token number">999</span>

<span class="token comment"># 1. 查看游戏帮助</span>
Game<span class="token punctuation">.</span>show_help<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment"># 2. 查看游戏最高分</span>
Game<span class="token punctuation">.</span>show_top_score<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment"># 3. 创建游戏对象，开始游戏</span>
game <span class="token operator">=</span> Game<span class="token punctuation">(</span><span class="token string">"小明"</span><span class="token punctuation">)</span>

game<span class="token punctuation">.</span>start_game<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment"># 4. 游戏结束，查看游戏最高分</span>
Game<span class="token punctuation">.</span>show_top_score<span class="token punctuation">(</span><span class="token punctuation">)</span>

</pre><h1 class="mume-header" id="%E5%8D%95%E4%BE%8B">单例</h1>

<h2 class="mume-header" id="%E7%9B%AE%E6%A0%87-3">目标</h2>

<ul>
<li>单例设计模式</li>
<li><code>__new__</code> 方法</li>
<li>Python 中的单例</li>
</ul>
<h2 class="mume-header" id="01-%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">01. 单例设计模式</h2>

<ul>
<li>
<p>设计模式</p>
<ul>
<li><strong>设计模式</strong> 是 <strong>前人工作的总结和提炼</strong>，通常，被人们广泛流传的设计模式都是针对 <strong>某一特定问题</strong> 的成熟的解决方案</li>
<li>使用 <strong>设计模式</strong> 是为了可重用代码、让代码更容易被他人理解、保证代码可靠性</li>
</ul>
</li>
<li>
<p>单例设计模式</p>
<ul>
<li><strong>目的</strong> —— 让 <strong>类</strong> 创建的对象，在系统中 <strong>只有</strong> <strong>唯一的一个实例</strong></li>
<li>每一次执行 <code>类名()</code> 返回的对象，<strong>内存地址是相同的</strong></li>
</ul>
</li>
</ul>
<h3 class="mume-header" id="%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">单例设计模式的应用场景</h3>

<ul>
<li><strong>音乐播放</strong> 对象</li>
<li><strong>回收站</strong> 对象</li>
<li><strong>打印机</strong> 对象</li>
<li>……</li>
</ul>
<h2 class="mume-header" id="02-__new__-%E6%96%B9%E6%B3%95">02. <code>__new__</code> 方法</h2>

<ul>
<li>使用 <strong>类名()</strong> 创建对象时，<code>Python</code> 的解释器 <strong>首先</strong> 会 调用 <code>__new__</code> 方法为对象 <strong>分配空间</strong></li>
<li><code>__new__</code> 是一个 由 <code>object</code> 基类提供的 <strong>内置的静态方法</strong>，主要作用有两个：
<ul>
<li>
<ol>
<li>在内存中为对象 <strong>分配空间</strong></li>
</ol>
</li>
<li>
<ol start="2">
<li><strong>返回</strong> 对象的引用</li>
</ol>
</li>
</ul>
</li>
<li><code>Python</code> 的解释器获得对象的 <strong>引用</strong> 后，将引用作为 <strong>第一个参数</strong>，传递给 <code>__init__</code> 方法</li>
</ul>
<blockquote>
<p>重写 <code>__new__</code> 方法 的代码非常固定！</p>
</blockquote>
<ul>
<li>重写 <code>__new__</code> 方法 <strong>一定要</strong> <code>return super().__new__(cls)</code></li>
<li>否则 Python 的解释器 <strong>得不到</strong> 分配了空间的 <strong>对象引用</strong>，<strong>就不会调用对象的初始化方法</strong></li>
<li>注意：<code>__new__</code> 是一个静态方法，在调用时需要 <strong>主动传递</strong> <code>cls</code> 参数</li>
</ul>
<p><img src="media/15016413216376/022_%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E7%A9%BA%E9%97%B4%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96.png" alt="022_&#x5BF9;&#x8C61;&#x5206;&#x914D;&#x7A7A;&#x95F4;&#x548C;&#x521D;&#x59CB;&#x5316;-w838"></p>
<p><strong>示例代码</strong></p>
<pre data-role="codeBlock" data-info="python" class="language-python"><span class="token keyword">class</span> <span class="token class-name">MusicPlayer</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>

    <span class="token keyword">def</span> <span class="token function">__new__</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 如果不返回任何结果，</span>
        <span class="token keyword">return</span> <span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__new__<span class="token punctuation">(</span>cls<span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"初始化音乐播放对象"</span><span class="token punctuation">)</span>

player <span class="token operator">=</span> MusicPlayer<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">print</span><span class="token punctuation">(</span>player<span class="token punctuation">)</span>

</pre><h2 class="mume-header" id="03-python-%E4%B8%AD%E7%9A%84%E5%8D%95%E4%BE%8B">03. Python 中的单例</h2>

<ul>
<li><strong>单例</strong> —— 让 <strong>类</strong> 创建的对象，在系统中 <strong>只有</strong> <strong>唯一的一个实例</strong>
<ol>
<li>定义一个 <strong>类属性</strong>，初始值是 <code>None</code>，用于记录 <strong>单例对象的引用</strong></li>
<li>重写 <code>__new__</code> 方法</li>
<li>如果 <strong>类属性</strong> <code>is None</code>，调用父类方法分配空间，并在类属性中记录结果</li>
<li>返回 <strong>类属性</strong> 中记录的 <strong>对象引用</strong></li>
</ol>
</li>
</ul>
<p><img src="media/15016413216376/023_%E5%8D%95%E4%BE%8B%E6%B5%81%E7%A8%8B.png" alt="023_&#x5355;&#x4F8B;&#x6D41;&#x7A0B;-w893"></p>
<pre data-role="codeBlock" data-info="python" class="language-python"><span class="token keyword">class</span> <span class="token class-name">MusicPlayer</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>

    <span class="token comment"># 定义类属性记录单例对象引用</span>
    instance <span class="token operator">=</span> <span class="token boolean">None</span>

    <span class="token keyword">def</span> <span class="token function">__new__</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>

        <span class="token comment"># 1. 判断类属性是否已经被赋值</span>
        <span class="token keyword">if</span> cls<span class="token punctuation">.</span>instance <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
            cls<span class="token punctuation">.</span>instance <span class="token operator">=</span> <span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__new__<span class="token punctuation">(</span>cls<span class="token punctuation">)</span>

        <span class="token comment"># 2. 返回类属性的单例引用</span>
        <span class="token keyword">return</span> cls<span class="token punctuation">.</span>instance

</pre><h3 class="mume-header" id="%E5%8F%AA%E6%89%A7%E8%A1%8C%E4%B8%80%E6%AC%A1%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E4%BD%9C">只执行一次初始化工作</h3>

<ul>
<li>在每次使用 <code>类名()</code> 创建对象时，<code>Python</code> 的解释器都会自动调用两个方法：
<ul>
<li><code>__new__</code> 分配空间</li>
<li><code>__init__</code> 对象初始化</li>
</ul>
</li>
<li>在上一小节对 <code>__new__</code> 方法改造之后，每次都会得到 <strong>第一次被创建对象的引用</strong></li>
<li>但是：<strong>初始化方法还会被再次调用</strong></li>
</ul>
<p><strong>需求</strong></p>
<ul>
<li>让 <strong>初始化动作</strong> 只被 <strong>执行一次</strong></li>
</ul>
<p><strong>解决办法</strong></p>
<ol>
<li>定义一个类属性 <code>init_flag</code> 标记是否 <strong>执行过初始化动作</strong>，初始值为 <code>False</code></li>
<li>在 <code>__init__</code> 方法中，判断 <code>init_flag</code>，如果为 <code>False</code> 就执行初始化动作</li>
<li>然后将 <code>init_flag</code> 设置为 <code>True</code></li>
<li>这样，再次 <strong>自动</strong> 调用 <code>__init__</code> 方法时，<strong>初始化动作就不会被再次执行</strong> 了</li>
</ol>
<pre data-role="codeBlock" data-info="python" class="language-python"><span class="token keyword">class</span> <span class="token class-name">MusicPlayer</span><span class="token punctuation">(</span><span class="token builtin">object</span><span class="token punctuation">)</span><span class="token punctuation">:</span>

    <span class="token comment"># 记录第一个被创建对象的引用</span>
    instance <span class="token operator">=</span> <span class="token boolean">None</span>
    <span class="token comment"># 记录是否执行过初始化动作</span>
    init_flag <span class="token operator">=</span> <span class="token boolean">False</span>

    <span class="token keyword">def</span> <span class="token function">__new__</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>

        <span class="token comment"># 1. 判断类属性是否是空对象</span>
        <span class="token keyword">if</span> cls<span class="token punctuation">.</span>instance <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
            <span class="token comment"># 2. 调用父类的方法，为第一个对象分配空间</span>
            cls<span class="token punctuation">.</span>instance <span class="token operator">=</span> <span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__new__<span class="token punctuation">(</span>cls<span class="token punctuation">)</span>

        <span class="token comment"># 3. 返回类属性保存的对象引用</span>
        <span class="token keyword">return</span> cls<span class="token punctuation">.</span>instance

    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>

        <span class="token keyword">if</span> <span class="token operator">not</span> MusicPlayer<span class="token punctuation">.</span>init_flag<span class="token punctuation">:</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"初始化音乐播放器"</span><span class="token punctuation">)</span>

            MusicPlayer<span class="token punctuation">.</span>init_flag <span class="token operator">=</span> <span class="token boolean">True</span>


<span class="token comment"># 创建多个对象</span>
player1 <span class="token operator">=</span> MusicPlayer<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>player1<span class="token punctuation">)</span>

player2 <span class="token operator">=</span> MusicPlayer<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>player2<span class="token punctuation">)</span>

</pre>
      </div>
      
      
    </body>
    
    
    
    
    
    
    
  </html>